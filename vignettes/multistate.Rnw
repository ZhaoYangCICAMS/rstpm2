%\VignetteIndexEntry{Predictions for Markov multi-state models}
%\VignetteDepends{rstpm2}
%\VignetteKeyword{survival, spline}
%\VignettePackage{rstpm2}
%!\SweaveUTF8

\documentclass[nojss]{jss}

\usepackage{amsmath,amsfonts,enumitem,fancyvrb,hyperref}
\usepackage[utf8]{inputenc}
\VerbatimFootnotes
\usepackage[margin=2.6cm]{geometry} % wide margins
\usepackage{wasysym}
\usepackage{tablefootnote}
\usepackage{algorithm2e}

\title{Predictions for Markov multi-state models}

\author{Mark~Clements\\Karolinska Institutet}

\Plainauthor{Mark~Clements}

\Plaintitle{Markov multi-state models}

\Abstract{
  
  We describe an efficient algorithm and implementation for
  predictions for Markov multi-state models, including state occupancy
  probabilities, length of stay and costs. The algorithm uses a system
  of ordinary differential equations to calculate the predictions and
  their gradients, with standard errors calculated using the delta
  method. The implementation is 50 times faster than the MULTISTATE
  package in Stata. These methods have applications to a range of
  disciplines, including descriptive epidemiology, causal inference and economics.
  
}

\Keywords{survival, multi-state models, Markov models}

\Plainkeywords{multi-state models, Markov models}

\Address{Mark~Clements\\
  Department of Medical Epidemiology and Biostatistics\\
  Karolinska Institutet\\
  Email: \email{mark.clements@ki.se}
  }

\begin{document}

\section{Introduction}

\emph{Multi-state models} form a very broad class of models that includes standard survival models with an initial and final state, competing risks with multiple final states, and illness-death models, with an initial healthy state, an illness state and a death state. This model class is useful for representing movement through a discrete set of states. As examples, we may be interested in representing cancer screening, diagnosis and treatment pathways. 

This short note describes an efficient algorithm for calculating a range of parameters from a multi-state model. The focus here is on \emph{non-homogeneous Markov} multi-state models, with one time scale (e.g. calendar period or attained age) without any time resetting. The implementation also assumes that the transition intensities for moving from one state to another state are \emph{continuous}. Importantly, the restriction to Markov models is not a heavy constraint: \cite{Datta_Satten_2001} have shown that the state occupancy probabilities are consistently estimated under moderate conditions even when the time scale is mis-specified. Length of stay and costs, which are integrated functions of the stage occupancy probabilities, are also expected to be consistent under similar conditions.

In outline, we provide a theoretical development of a set of ordinary differential equations, outline an algorithm, describe the implementation and provide some simple examples.

\section{Methods}

Let the set of states be indexed by $i$ and $j$. We define the row vector of state occupancy probabilities $\boldsymbol{P}(t_0,t)=(P_{0j}(t_0,t))$ as the probabilities of being in state $j$ at time $t$ given being in an initial state $0$ at entry time $t_0$. For smooth hazards, the Markov property is expressed through Kolmogorov's forward differential equation, such that 
\begin{align}
  \frac{d\boldsymbol{P}(t_0,t)}{dt} &= \boldsymbol{P}(t_0,t) \boldsymbol{Q}(t) \label{eq:kolmogorov}
\end{align}
where $\boldsymbol{Q}(t)=(Q_{ij}(t))$ is a matrix of transition intensities at time $t$\footnote{Technically, this is $t-$.} from state $i$ to state $j$ when $i\neq j$ (conceptualised as the rates from state $i$ to state $j$), and where $Q_{ii}(t)=-\sum_{j\neq i}Q_{ij}(t)$ (conceptualised as the rates out of state $i$). % The Markov property is based on a single clock $t$ (e.g. age of a subject or calendar time), whereas semi-Markov models are based on a reset clock (e.g. time in state for each new state).

This system of ordinary differential equations in Equation~\ref{eq:kolmogorov} can be augmented to calculate the integral $L_{0j}(t_0,t)=\int_{t_0}^t P_{0j}(t_0,v)u_j(u)e^{-\lambda t}dv$, where 0 is again the index for the initial state, $u_j(v)$ is the utility for state $j$ at time $v$ and $\lambda=\log(1+\delta)$ is the rate of decline for a discount rate $\delta$. The augmented differential equations are then
\begin{align}
\frac{d\boldsymbol{L}(t_0,t)}{dt} &= \left(\boldsymbol{P}(t_0,t)\circ\boldsymbol{u}(t)\right)e^{-\lambda t} \label{eq:los}
\end{align}
where $\boldsymbol{P}(t_0,t)\circ\boldsymbol{u}(t)$ is the Hadamard (element-wise) product between row vector $\boldsymbol{P}(t_0,t)$ and row vector $\boldsymbol{u}(t)$.
In health economics, the sum across the states gives the discounted, quality-adjusted life-years $\text{QALY}(t_0,t)=\boldsymbol{L}(t_0,t)\boldsymbol{1}$. If $u_j(v)=1$ and $\lambda=0$ then $L_{0j}(t_0,t)$ is the the \emph{length of stay} or sojourn time for state $j$; see \cite{Jackson_2016} for an implementation to predict the length of stay using ordinary differential equations. We can also augment the system to model for costs per unit time for being in state $i$ at time $t$, represented by the row vector function $\boldsymbol{c}(t)=(c_{i}(t))$ and model for costs for transitions from state $i$ to state $j$ at time $t$, represented by the matrix $\boldsymbol{\mathcal{C}}(t)=(\mathcal{C}_{i,j}(t))$. Then the cumulative costs $\boldsymbol{C}(t_0,t)$ can be represented by the equations
\begin{align}
\frac{d\boldsymbol{C}(t_0,t)}{dt} &= \left(\left(\boldsymbol{P}(t_0,t)\circ\boldsymbol{c}(t)\right)+
                                    \boldsymbol{P}(t_0,t)(\boldsymbol{Q}(t)\circ \boldsymbol{\mathcal{C}}(t))\right)e^{-\lambda t} \label{eq:costs}
\end{align}
where $\boldsymbol{Q}(t)\circ \boldsymbol{\mathcal{C}}(t)$ is the Hadamard product between matrix $\boldsymbol{Q}(t)$ and matrix $\boldsymbol{\mathcal{C}}(t)$. The total costs are summed across the health states, such that $\text{Costs}(t_0,t)=\boldsymbol{C}(t_0,t)\boldsymbol{1}$.

The initial values for Equations~(\ref{eq:kolmogorov})--(\ref{eq:costs}) are     $\boldsymbol{P}(t_0,t_0)=\boldsymbol{I}$ and $\boldsymbol{L}(t_0,t_0)=\boldsymbol{C}(t_0,t_0)=\boldsymbol{0}$.


\subsection{ODE augmentation to calculate gradients}

Following \cite{Titman_2011}, this system of equations can be further augmented to calculate the gradient for $\boldsymbol{P}(t_0,t)$ with respect to model coefficients $\boldsymbol\beta=(\beta_m)$; for $\beta_m$, we represent this value by $\boldsymbol{P}'_m(t_0,t)$. Titman showed that
\begin{align}
  \frac{d\boldsymbol{P}'_m(t_0,t)}{dt} &=\boldsymbol{P}'_m(t_0,t)\boldsymbol{Q}(t) + \boldsymbol{P}(t_0,t)\boldsymbol{Q}'_m(t) \label{eq:dPudt}
\end{align}
Note that this requires the evaluation of the gradients for the transition intensities. As extensions, we can also calculate the gradient for $\boldsymbol{L}(t_0,t)$ with respect to $\beta_m$, such that
\begin{align}
  \frac{d\boldsymbol{L}'_m(t_0,t)}{dt} &= \left(\left(\boldsymbol{P}'_m(t_0,t)\circ\boldsymbol{u}(t)\right)+\left(\boldsymbol{P}(t_0,t)\circ\boldsymbol{u}'_m(t)\right)\right)e^{-\lambda t} \label{eq:dLudt}
\end{align}
and the gradients for the cumulative costs, such that
\begin{align}
  \frac{d\boldsymbol{C}'_m(t_0,t)}{dt} &= \Big(\left(\boldsymbol{P}'_m(t_0,t)\circ\boldsymbol{c}(t)\right)+ \left(\boldsymbol{P}(t_0,t)\circ\boldsymbol{c}'_m(t)\right)+\nonumber\\
                                         &\qquad \boldsymbol{P}'_m(t_0,t)\left(\boldsymbol{Q}(t)\circ \boldsymbol{\mathcal{C}}(t)\right)+\nonumber\\
                                         &\qquad \boldsymbol{P}(t_0,t)\left(\boldsymbol{Q}'_m(t)\circ \boldsymbol{\mathcal{C}}(t)\right)+\nonumber\\
                                         &\qquad\boldsymbol{P}(t_0,t)\left(\boldsymbol{Q}(t)\circ \boldsymbol{\mathcal{C}}'_m(t)\right)
                                         \Big)e^{-\lambda t} \label{eq:dCudt}
\end{align}
Note that Equations~(\ref{eq:dLudt}) and (\ref{eq:dCudt}) may require the evaluation of the gradients for the utility and cost functions, respectively. These equations simplify when the utilities $\boldsymbol{u}(t)$ and cost functions $\boldsymbol{c}(t)$ and $\boldsymbol{\mathcal{C}}(t)$ are fixed and have zero gradients.

The initial values for Equations~(\ref{eq:dPudt})--(\ref{eq:dCudt}) are
$\boldsymbol{P}'_m(t_0,t_0)=\boldsymbol{L}'_m(t_0,t_0)=\boldsymbol{C}'_m(t_0,t_0)=\boldsymbol{0}$.


\subsection{Algorithm}

The algorithm is defined by the following:

\begin{algorithm}[H]
  \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
  \Input{$\boldsymbol{P}(t_0,t_0),\boldsymbol{Q}(t), \boldsymbol{u}(t), \boldsymbol{c}(t), \boldsymbol{\mathcal{C}}(t), \left\{\boldsymbol{Q}'_m(t),\boldsymbol{u}'_m(t),\boldsymbol{c}'_m(t), \boldsymbol{\mathcal{C}}'_m(t)\right\}\forall m, \lambda, t_0, t_\text{max}$} \Output{$\boldsymbol{P}(t_0,t),\boldsymbol{L}(t_0,t),\boldsymbol{C}(t_0,t),\left\{\boldsymbol{P}'_m(t_0,t),\boldsymbol{L}'_m(t_0,t),\boldsymbol{C}'_m(t_0,t)\right\}\forall m\ \text{for}\ t\in\left[t_0,t_\text{max}\right)$}
  \Begin{

  $\boldsymbol{P}'_m(t_0,t_0)=\boldsymbol{L}'_m(t_0,t_0)=\boldsymbol{C}'_m(t_0,t_0)=\boldsymbol{0}$\;
  define the ODE based on Equations~(\ref{eq:kolmogorov})--(\ref{eq:dCudt}) and the initial values\;
  run an ODE solver from time $t_0$ to time $t_\text{max}$\;
  }
\end{algorithm}

This algorithm could be done separately for each covariate pattern or the ODEs can be extended to multiple covariates by stacking the equations.

\subsection{Variance estimation and other predictions}

For the following, let $\boldsymbol\phi(t_0,t)$ represent one of $\boldsymbol{P}(t_0,t)$, $\boldsymbol{L}(t_0,t)$ or $\boldsymbol{C}(t_0,t)$, let $\boldsymbol\phi'_m(t_0,t)$ represent the derivative with respect to $\beta_m$, and let the covariance matrix for the estimated $\boldsymbol\beta$ be $\boldsymbol\Sigma$. Then, using the \emph{delta method}, the estimated covariance matrix for $\boldsymbol\phi(t_0,t)$ is
\begin{align*}
\text{var}(\boldsymbol\phi(t_0,t)) &= \boldsymbol{\phi}'_m(t_0,t)^T\, \boldsymbol\Sigma\, \boldsymbol{\phi}'_m(t_0,t)
\end{align*}

We can standardise the estimators using weighted sums with weights $w_k$ and covariates $\boldsymbol{x}_k$ for $k=1,\ldots,K$, such that
\begin{align*}
  \bar{\boldsymbol{\phi}}(t_0,t) &= \sum_{k=1}^K w_k \boldsymbol{\phi}(t_0,t|\boldsymbol{x}_k)\\
  \bar{\boldsymbol{\phi}}'_m(t_0,t) &= \sum_{k=1}^K w_k \boldsymbol{\phi}'_m(t_0,t|\boldsymbol{x}_k) % \\
%  \text{var}(\bar{\boldsymbol{\phi}}(t_0,t)) &= \bar{\boldsymbol{\phi}}'_m(t_0,t)^T\, \boldsymbol\Sigma\, \bar{\boldsymbol{\phi}}'_m(t_0,t)
\end{align*}

Similarly, we have that the partial derivatives with respect to the regression parameters for QALYs and total costs are
\begin{align*}
 \text{QALY}'_m(t_0,t) &\equiv \frac{\partial}{\partial \beta_m} \text{QALY}(t_0,t) = \boldsymbol{L}'_m(t_0,t)\boldsymbol{1} \\
   \text{Costs}'_m(t_0,t) &\equiv \frac{\partial}{\partial \beta_m} \text{Costs}(t_0,t)
  = \boldsymbol{C}'_m(t_0,t)\boldsymbol{1}
\end{align*} 

We can also consider differences and ratios. The gradient for the difference is
\begin{align*}
\frac{\partial}{\partial \beta_m} \left(\boldsymbol\phi(t_0,t|\boldsymbol{x}_1) - \boldsymbol\phi(t_0,t|\boldsymbol{x}_2)\right) &= \boldsymbol{\phi}'_m(t_0,t|\boldsymbol{x}_1) - \boldsymbol\phi'_m(t_0,t|\boldsymbol{x}_2)
\end{align*}
The gradient for the log of the ratio is 
\begin{align*}
\frac{\partial}{\partial \beta_m} \log\left(\frac{\boldsymbol\phi(t_0,t|\boldsymbol{x}_1)}{\boldsymbol\phi(t_0,t|\boldsymbol{x}_2)}\right) &= \frac{\boldsymbol{\phi}'_m(t_0,t|\boldsymbol{x}_1)}{\boldsymbol\phi(t_0,t|\boldsymbol{x}_1)}
- \frac{\boldsymbol{\phi}'_m(t_0,t|\boldsymbol{x}_2)}{\boldsymbol\phi(t_0,t|\boldsymbol{x}_2)}
\end{align*}
where the division $\left(\frac{\boldsymbol{\phi}'_m}{\boldsymbol{\phi}}\right)_j=\phi'_{m,j}/\phi_j$, which is element-wise division. We can also consider incremental cost-effectiveness ratios, estimated by 
\begin{align*}
\text{ICER}(t_0,t,\boldsymbol{x}_1,\boldsymbol{x}_2) &= \frac{\text{Costs}(t_0,t|\boldsymbol{x}_1)-\text{Costs}(t_0,t|\boldsymbol{x}_2)}{\text{QALY}(t_0,t|\boldsymbol{x}_1)-\text{QALY}(t_0,t|\boldsymbol{x}_2)}
\end{align*}
The gradient of the log of the ICER is 
\begin{align*}
\frac{\partial}{\partial\beta_m}\log(\text{ICER}(t_0,t,\boldsymbol{x}_1,\boldsymbol{x}_2)) 
  &= \frac{\text{Costs}'_m(t_0,t|\boldsymbol{x}_1)-\text{Costs}'_m(t_0,t|\boldsymbol{x}_2)}{\text{Costs}(t_0,t|\boldsymbol{x}_2)-\text{Costs}(t_0,t|\boldsymbol{x}_1)} - \\
&\qquad \frac{\text{QALY}'_m(t_0,t|\boldsymbol{x}_1)-\text{QALY}'_m(t_0,t|\boldsymbol{x}_2)}{\text{QALY}(t_0,t|\boldsymbol{x}_1)-\text{QALY}(t_0,t|\boldsymbol{x}_2)} \\
  &= \frac{\left(\boldsymbol{C}'_m(t_0,t|\boldsymbol{x}_1) - \boldsymbol{C}'_m(t_0,t|\boldsymbol{x}_2)\right)\boldsymbol{1}}{\left(\boldsymbol{C}(t_0,t|\boldsymbol{x}_1) - \boldsymbol{C}(t_0,t|\boldsymbol{x}_2)\right)\boldsymbol{1}} - 
    \frac{\left(\boldsymbol{L}'_m(t_0,t|\boldsymbol{x}_1) - \boldsymbol{L}'_m(t_0,t|\boldsymbol{x}_2)\right)\boldsymbol{1}}{\left(\boldsymbol{L}(t_0,t|\boldsymbol{x}_1) - \boldsymbol{L}(t_0,t|\boldsymbol{x}_2)\right)\boldsymbol{1}}
\end{align*}
Given the gradients and $\boldsymbol\Sigma$, the covariance matrices
for $\bar{\boldsymbol{\phi}}(t_0,t)$, QALYs, total tosts,
differences, ratios and ICERs can be calculated using the delta
method. Confidence intervals can be calculated using the delta method
and assuming asymptotic normality. For estimators that are bounded
between 0 and 1, one can use a $\log(-\log(\cdot))$ transformation,
while estimators bounded between 0 and $\infty$ can use a log
transformation.

% Representation of different interventions - how?

\section{Implementation}

We have implemented the algorithm in \code{R} within the \code{rstpm2} package using the function \code{markov_msm}. The ODE solver uses the \code{ode} function from the \code{deSolve} package with the Adams method for non-stiff ODEs. The \code{markov_msm} scales reasonably well with multiple covariates within the same system of ODEs.

A basic call to \code{markov_msm()} to estimate the state occupancy probabilities and length of stay would be \code{markov_msm(x, trans, t, newdata)}, where \code{x} is a list of regression models for the transition intensities, \code{trans} is a matrix that defines the multistate transitions as per the \code{mstate} package, \code{t} is a vector of times to report (including the initial time), and \code{newdata} is a data-frame with the covariates for predictions.

The current implementation assumes independently estimated transition intensities. The models for the transition intensities need to provide methods for: (i) the covariance matrix (\code{vcov}); (ii) predictions for hazards (\code{predict(object, newdata, type="haz", ...)}); and (iii) predictions for gradients of the hazards (\code{predict(object, newdata, type="gradh", ...)}). These methods have been provided for \code{rstpm2::stpm2}, \code{rtspm2::pstpm2}, \code{stats::glm} for a log link, and \code{survPen::survPen}. Use of \code{stats::glm} will also require that the argument \code{tvar} to specify a character for the name (or vector of names) of the time variables in the regression models for predictions. A transition can be turned off by wrapping a regression object in \code{zeroRate()}.
% Should I use a common S3 or S4 class?

The object returned from \code{markov_msm()} is of class \code{"markov_msm"}. The object includes predictions and gradients for the times specified for the covariates in the input \code{newdata} data-frame. Methods are provided for: \code{print}; \code{as.data.frame}; \code{subset(x, subset, ...)} based on a restriction of \code{newdata}; \code{standardise}, which averages across covariate patterns and returns another \code{markov_msm} object. Other functions include \code{diff(x,y)} which takes a difference between two \code{markov_msm} objects, and \code{ratio_markov_msm}, which gives the ratio of two \code{markov_msm} objects; both of these functions return objects that inherit from \code{"markov_msm"}.

% Differences from the same models are just different weights...

\section{Example}

We follow the example by \cite{Crowther_Lambert_2017}.



(We could extend the example used by Jackson to include standardisation.)



\bibliography{lib.bib}

\end{document}
